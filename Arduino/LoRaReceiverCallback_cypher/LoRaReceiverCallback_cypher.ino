#include <SPI.h>
#include <LoRa.h>
#include <Cipher.h>
#include <AES.h>
#include <CBC.h>
#include <string.h>

#ifdef ARDUINO_SAMD_MKRWAN1300
#error "This example is not compatible with the Arduino MKR WAN 1300 board!"
#endif

//define the pins used by the receiver module
#define NSS 10
#define RST 9
#define DIO0 2

void unpadPKCS7(uint8_t *data, size_t &length) {
    uint8_t padding_value = data[length - 1];
    length -= padding_value;
}

void setup() {
  Serial.begin(9600);
  while (!Serial);

  Serial.println("LoRa Receiver Callback");

  LoRa.setPins(NSS, RST, DIO0);

  if (!LoRa.begin(433E6)) {
    Serial.println("Starting LoRa failed!");
    while (1);
  }

  LoRa.setSignalBandwidth(500E3);
  LoRa.setSpreadingFactor(7);
  LoRa.setCodingRate4(5);

  LoRa.dumpRegisters(Serial);
  Serial.println("LoRa Receiver initated!");

  // Uncomment the next line to disable the default AGC and set LNA gain, values between 1 - 6 are supported
  // LoRa.setGain(6);
  
  // register the receive callback
  LoRa.onReceive(onReceive);

  // put the radio into receive mode
  LoRa.receive();
}

void loop() {
  // do nothing
}

void onReceive(int packetSize) {
  // received a packet
  Serial.print("Received packet '");

  //LoRa.dumpRegisters(Serial);

  uint8_t received_message[packetSize];
  int i = 0;

  uint8_t key[16] = {0xC3, 0x24, 0x64, 0x98, 0xDE, 0x56, 0x5D, 0x8C, 
                    0x55, 0x88, 0x7C, 0x05, 0x86, 0xF9, 0x82, 0x26};

  // Legge i byte ricevuti e li memorizza
  while (LoRa.available()) {
    received_message[i++] = LoRa.read();
  }

  // Estrai IV (primi 16 byte)
  uint8_t iv[16];
  memcpy(iv, received_message, 16);

  // Estrai ciphertext
  size_t ciphertext_length = packetSize - 16;
  uint8_t ciphertext[ciphertext_length];
  memcpy(ciphertext, received_message + 16, ciphertext_length);

  // Buffer per il messaggio decifrato
  uint8_t plaintext[ciphertext_length];

  // Configura AES CBC per la decifratura
  CBC<AES128> cbc;
  cbc.setKey(key, sizeof(key));
  cbc.setIV(iv, sizeof(iv));

  // Decifra il messaggio
  cbc.decrypt(plaintext, ciphertext, ciphertext_length);

  // Rimuovi il padding PKCS7
  size_t plaintext_length = ciphertext_length;
  unpadPKCS7(plaintext, plaintext_length);

  // Stampa il messaggio decifrato
  Serial.print("Messaggio decifrato: ");
  for (size_t j = 0; j < plaintext_length; j++) {
      Serial.print((char)plaintext[j]);
  }
  
  // print RSSI of packet
  Serial.print("' with RSSI ");
  Serial.println(LoRa.packetRssi());
}

/*
'0x0: 0x39
0x1: 0x85
0x2: 0x1A
0x3: 0xB
0x4: 0x0
0x5: 0x52
0x6: 0x6C
0x7: 0x40
0x8: 0x0
0x9: 0x8F
0xA: 0x9
0xB: 0x2B
0xC: 0x23
0xD: 0x1
0xE: 0x0
0xF: 0x0
0x10: 0x0
0x11: 0x0
0x12: 0x0
0x13: 0x10
0x14: 0x0
0x15: 0x1
0x16: 0x0
0x17: 0x0
0x18: 0x24
0x19: 0x17
0x1A: 0x79
0x1B: 0x40
0x1C: 0x0
0x1D: 0x92
0x1E: 0x70
0x1F: 0x64
0x20: 0x0
0x21: 0x8
0x22: 0x1
0x23: 0xFF
0x24: 0x0
0x25: 0x10
0x26: 0x4
0x27: 0x0
0x28: 0x0
0x29: 0x4
0x2A: 0xC0
0x2B: 0x0
0x2C: 0xE
0x2D: 0x50
0x2E: 0x14
0x2F: 0x40
0x30: 0x0
0x31: 0xC3
0x32: 0x5
0x33: 0x27
0x34: 0x1C
0x35: 0xA
0x36: 0x3
0x37: 0xA
0x38: 0x42
0x39: 0x12
0x3A: 0x58
0x3B: 0x1D
0x3C: 0x0
0x3D: 0xAF
0x3E: 0x0
0x3F: 0x0
0x40: 0x0
0x41: 0x0
0x42: 0x12
0x43: 0x24
0x44: 0x2D
0x45: 0x0
0x46: 0x3
0x47: 0x0
0x48: 0x4
0x49: 0x23
0x4A: 0x0
0x4B: 0x9
0x4C: 0x5
0x4D: 0x84
0x4E: 0x32
0x4F: 0x2B
0x50: 0x14
0x51: 0x0
0x52: 0x0
0x53: 0xD
0x54: 0x0
0x55: 0x0
0x56: 0x0
0x57: 0xF
0x58: 0xE0
0x59: 0x0
0x5A: 0xC
0x5B: 0xF6
0x5C: 0x7
0x5D: 0x0
0x5E: 0x5C
0x5F: 0x78
0x60: 0x0
0x61: 0x1C
0x62: 0xE
0x63: 0x5B
0x64: 0xCC
0x65: 0x0
0x66: 0x1
0x67: 0x50
0x68: 0x0
0x69: 0x0
0x6A: 0x0
0x6B: 0x0
0x6C: 0x0
0x6D: 0x0
0x6E: 0x0
0x6F: 0xB
0x70: 0xD0
0x71: 0x0
0x72: 0x14
0x73: 0x0
0x74: 0x0
0x75: 0x0
0x76: 0x0
0x77: 0x0
0x78: 0x0
0x79: 0x0
0x7A: 0x0
0x7B: 0x0
0x7C: 0x0
0x7D: 0x0
0x7E: 0x0
0x7F: 0x0
*/
